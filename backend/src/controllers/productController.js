import Product from "../models/Product.js";

// ==========================================
// 1. ADD PRODUCT (Fixed for New Schema)
// ==========================================
export const addProduct = async (req, res) => {
  try {
    const sellerId = req.user._id;

    // 1. Destructure incoming flat data (from React Form)
    const {
      name,
      description,
      brand,
      net_quantity,      // e.g. "1 Box"
      selling_price,     // e.g. "500"
      mrp,               // e.g. "1000"
      gst_percentage,    // e.g. "18"
      category_main,     // e.g. "Sparklers"
      category_sub,      // e.g. "10cm"
      stock_boxes,       // e.g. "50" (Wholesale logic)
      pieces_per_box,    // e.g. "10"
      min_order_qty,
      specifications,    // JSON string or array
      video_url,
      is_combo
    } = req.body;

    // 2. Validate Required Fields manually (Optional but good for UX)
    if (!name || !selling_price || !category_main || !net_quantity) {
      return res.status(400).json({ 
        message: "Name, Selling Price, Category, and Net Quantity are required" 
      });
    }

    // 3. Construct the Nested Data Object
    const productData = {
      sellerId,
      name: name.trim(),
      description: description?.trim(),
      brand: brand || "Standard",
      net_quantity,

      // MAP TO NEW PRICING SCHEMA
      pricing: {
        selling_price: Number(selling_price),
        mrp: mrp ? Number(mrp) : undefined,
        gst_percentage: Number(gst_percentage) || 18
      },

      // MAP TO NEW CATEGORY SCHEMA
      category: {
        main: category_main,
        // 'main_slug' will be auto-generated by Schema Middleware
        main_slug: "temp", 
        sub: category_sub,
        sub_slug: "temp"
      },

      // MAP TO NEW STOCK SCHEMA
      stock_control: {
        total_boxes: Number(stock_boxes) || 0,
        pieces_per_box: Number(pieces_per_box) || 1,
        min_order_qty: Number(min_order_qty) || 1
      },

      // Handle Images (Multer)
      images: req.files ? req.files.map((f) => f.path) : [],
      
      video_url,
      is_combo: is_combo === 'true' || is_combo === true,
      status: "pending"
    };

    // 4. Handle Specifications (Parse JSON string if needed)
    if (specifications) {
      try {
        const specs = typeof specifications === 'string' 
          ? JSON.parse(specifications) 
          : specifications;
          
        productData.specifications = specs.map(s => ({
          key: s.key,
          value: s.value,
          value_num: Number(s.value) || undefined,
          unit: s.unit
        }));
      } catch (e) {
        console.error("Spec parsing error", e);
      }
    }

    // 5. Save to DB (Triggers Middleware for Slugs & Stock Calc)
    const newProduct = new Product(productData);
    await newProduct.save();

    res.status(201).json({
      success: true,
      message: "Product submitted for approval",
      product: newProduct
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to add product",
      error: err.message
    });
  }
};

// ==========================================
// 2. GET SELLER PRODUCTS (Fixed)
// ==========================================
export const getSellerProducts = async (req, res) => {
  try {
    const sellerId = req.user._id;
    
    // Use .lean() for faster read performance
    const products = await Product.find({ sellerId, is_deleted: false })
      .sort({ createdAt: -1 })
      .lean();

    res.status(200).json({
      success: true,
      count: products.length,
      products
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to fetch products",
      error: err.message
    });
  }
};

// ==========================================
// 3. BULK IMPORT (Fixed Logic)
// ==========================================
export const bulkImportProducts = async (req, res) => {
  try {
    const sellerId = req.user._id;
    const { products } = req.body;

    if (!Array.isArray(products) || products.length === 0) {
      return res.status(400).json({ message: "No products provided" });
    }

    let successCount = 0;
    const errors = [];

    // CRITICAL: Use Loop to trigger Pre-Save Middleware (Slugs/Stock)
    for (let i = 0; i < products.length; i++) {
      const p = products[i];
      try {
        const newProduct = new Product({
          sellerId,
          name: p.name,
          net_quantity: p.net_quantity || "1 Box",
          
          pricing: {
            selling_price: p.selling_price,
            mrp: p.mrp
          },
          
          category: {
            main: p.category_main,
            main_slug: "temp",
            sub: p.category_sub
          },
          
          stock_control: {
            total_boxes: p.stock_boxes || 0,
            pieces_per_box: p.pieces_per_box || 1
          },
          
          images: ["placeholder.jpg"], // Bulk import placeholder
          status: "pending"
        });

        await newProduct.save();
        successCount++;
        
      } catch (err) {
        errors.push({ row: i + 1, error: err.message });
      }
    }

    res.status(200).json({
      success: true,
      imported: successCount,
      errors
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Bulk import failed",
      error: err.message
    });
  }
};


export const updateProduct = async (req, res) => {
  try {
    const { productId } = req.params;
    const sellerId = req.user._id;

    // Find product first to ensure ownership
    const product = await Product.findOne({ _id: productId, sellerId });

    if (!product) {
      return res.status(404).json({ message: "Product not found or unauthorized" });
    }

    // Destructure body (same as addProduct)
    const {
      name, description, brand, net_quantity,
      selling_price, mrp, gst_percentage,
      category_main, category_sub,
      stock_boxes, pieces_per_box, min_order_qty,
      specifications, video_url, is_combo, status
    } = req.body;

    // Update Basic Fields
    if (name) product.name = name.trim();
    if (description) product.description = description.trim();
    if (brand) product.brand = brand;
    if (net_quantity) product.net_quantity = net_quantity;
    if (video_url !== undefined) product.video_url = video_url;
    if (is_combo !== undefined) product.is_combo = is_combo === 'true' || is_combo === true;

    // Update Pricing (Handle nested)
    if (selling_price) product.pricing.selling_price = Number(selling_price);
    if (mrp) product.pricing.mrp = Number(mrp);
    if (gst_percentage) product.pricing.gst_percentage = Number(gst_percentage);

    // Update Category (Triggers slug middleware on save)
    if (category_main) product.category.main = category_main;
    if (category_sub) product.category.sub = category_sub;

    // Update Stock (Triggers available_pieces calculation on save)
    if (stock_boxes !== undefined) product.stock_control.total_boxes = Number(stock_boxes);
    if (pieces_per_box !== undefined) product.stock_control.pieces_per_box = Number(pieces_per_box);
    if (min_order_qty !== undefined) product.stock_control.min_order_qty = Number(min_order_qty);

    // Update Specifications
    if (specifications) {
      try {
        const specs = typeof specifications === 'string' ? JSON.parse(specifications) : specifications;
        product.specifications = specs.map(s => ({
          key: s.key,
          value: s.value,
          value_num: Number(s.value) || undefined,
          unit: s.unit
        }));
      } catch (e) {
        console.error("Spec parsing error during update", e);
      }
    }
    
    // If new images are uploaded, append or replace them (Logic depends on your UI)
    // For now, let's assume if files are sent, we replace them
    if (req.files && req.files.length > 0) {
        product.images = req.files.map((f) => f.path);
    }

    // Reset status to pending on significant edits if required
    // product.status = "pending"; 

    await product.save(); // Triggers pre-save hooks (Slugs, Stock Calc)

    res.status(200).json({
      success: true,
      message: "Product updated successfully",
      product
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to update product",
      error: err.message
    });
  }
};

// ==========================================
// 5. DELETE PRODUCT (Soft Delete)
// ==========================================
export const deleteProduct = async (req, res) => {
  try {
    const { productId } = req.params;
    const sellerId = req.user._id;

    // Soft delete: Find and update is_deleted flag
    const product = await Product.findOneAndUpdate(
      { _id: productId, sellerId },
      { is_deleted: true },
      { new: true }
    );

    if (!product) {
      return res.status(404).json({ message: "Product not found or unauthorized" });
    }

    res.status(200).json({
      success: true,
      message: "Product moved to trash"
    });

  } catch (err) {
    res.status(500).json({
      success: false,
      message: "Failed to delete product",
      error: err.message
    });
  }
};